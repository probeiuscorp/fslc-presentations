import './styles.css';
import { Highlight } from './Highlight.jsx';
import slidesTheme from './theme';
export const theme = slidesTheme;

# Algebraic Effects

In this presentation we'll be looking into modeling effects in pure functional programming.

Here's the outline:

1. What exactly is meant by _effects_?
2. The well-known: a glance of Functors, Applicative Functors and Monads
3. How are _algebraic effects_ different, and where/how can they improve our code?

## Source

The source of this presentation is on GitHub, at https://github.com/probeiuscorp/fslc-presentations.

---

# Part 1: What are _effects_?

---

# Consuming under constraints

But sometimes when we're working with the real world, our values aren't quite as pretty:

- The value may not exist (Maybe/Option)
- The value may not exist yet (Promise)
- The value may not exist, but if it doesn't we're given a why (Either/Result)
- There may be multiple values (List)
- The value may vary over time (Behavior/Signal)
- The value is produced outside our code / total control (IO)

In _some_ (gross) languages we're left totally on our own:
* We check for null every time we have to use it, and
* we set i=0 and i++ while i < length whenever we have to walk along the list

We shouldn't have to tell the computer how to traverse a list.
How do we simplify our code?

---

# In depth: Promises

Well-known approaches to this problem are the **Functor**, **Applicative Functor** and **Monad**.
We'll focus on Promises because they're rather pleasant to diagram.

<p>
  <Highlight>Here is a function.</Highlight>{' '}
  As we're coming from a functional perspective,
  let's do some groundwork and be exact with how we are defining functions.
  Functions receive some information and give us back new information.
  Everything is <strong>immutable</strong> and <strong>referentially transparent</strong>.
</p>

![](function.svg)

<p>
  <Highlight>And here is a Promise.</Highlight>{' '}
  Promises represent values which are pending (do not exist yet).
</p>

![](promise.svg)

---

# Functors

The simplest operation is to more or less forward the effects.
Maybe we're just not at the right layer to properly handle them.

Structures which permit this kind of operation are known as _Functors_.
Promises are Functors.

The fundamental operation is map, or `<$>`, which involves three values:
* `f a`, values of type `a` constrained by the Functor `f`
* `(a -> b)`, a function to take the input `a`s to output `b`s
* The output, `f b`: values of type `b` constrained by the same Functor `f`

![](promise-functor.svg)
